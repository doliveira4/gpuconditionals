<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GPU Conditionals Benchmark – snap45 Comparison</title>
  <!-- Ace Editor from CDN for syntax highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/ace.js" integrity="sha512-oRz6wK1oP5w8XaxJPmJYr++4jvtphKwLEdi+EbtxmH7cWFUhy9bWlL4RcpXqL7kBUHd21SkB98uP3imW6v9EXg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    /* Basic reset and full-viewport flex layout */
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      font-family: sans-serif;
      background: #111;
      color: #ddd;
    }
    body {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    /* Top control bar */
    #controls {
      flex: 0 0 50px;
      background-color: #222;
      padding: 10px;
      display: flex;
      align-items: center;
    }
    #controls label,
    #controls input {
      margin-right: 10px;
    }
    /* Main container for the two panels */
    #container {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      overflow: auto;
    }
    .panel {
      flex: 1 1 50%;
      box-sizing: border-box;
      padding: 10px;
      border: 1px solid #444;
      display: flex;
      flex-direction: column;
      min-width: 300px;
    }
    .panel h2 {
      margin: 0 0 5px;
      font-size: 1.1em;
    }
    /* Ace Editor container styling */
    .editor {
      width: 100%;
      height: 200px;
      border: 1px solid #555;
      margin-bottom: 5px;
    }
    .panel button {
      margin-bottom: 5px;
      padding: 5px 10px;
      background: #444;
      color: #ddd;
      border: none;
      cursor: pointer;
    }
    .panel button:hover {
      background: #555;
    }
    .panel canvas {
      flex: 1;
      width: 100%;
      background-color: #000;
      border: 1px solid #444;
      margin-top: 5px;
    }
    .metrics {
      margin-top: 5px;
      font-size: 0.9em;
    }
    /* Footer with Buy Me A Coffee button */
    #footer {
      flex: 0 0 60px;
      background-color: #222;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #footer a img {
      height: 60px;
      width: auto;
    }
  </style>
</head>
<body>
  <!-- Top control bar -->
  <div id="controls">
    <label for="thresholdSlider">Threshold:</label>
    <input type="range" id="thresholdSlider" min="0.1" max="2.0" step="0.01" value="1.0">
    <span id="thresholdValue">1.00</span>
  </div>

  <!-- Main container with two panels -->
  <div id="container">
    <!-- Branching shader panel -->
    <div class="panel">
      <h2>Branching Shader (if/else)</h2>
      <div id="branchEditor" class="editor"></div>
      <button id="compileBranch">Compile Branching Shader</button>
      <canvas id="branchCanvas"></canvas>
      <div class="metrics" id="branchMetrics">Frame Time: N/A</div>
    </div>
    <!-- Branchless shader panel -->
    <div class="panel">
      <h2>Branchless Shader (step + mix)</h2>
      <div id="branchlessEditor" class="editor"></div>
      <button id="compileBranchless">Compile Branchless Shader</button>
      <canvas id="branchlessCanvas"></canvas>
      <div class="metrics" id="branchlessMetrics">Frame Time: N/A</div>
    </div>
  </div>

  <!-- Footer with Buy Me A Coffee button -->
  <div id="footer">
    <a href="https://buymeacoffee.com/doliveira4" target="_blank">
      <img src="https://cdn.buymeacoffee.com/buttons/v2/default-blue.png" alt="Buy Me A Coffee">
    </a>
  </div>

  <!-- Main Script -->
  <script type="module">
    // WGSL shader code constants with fixes:
    // Vertex Position Fix and Uniform Alignment Fix are applied.
    const defaultBranchWGSL = `
// Branching shader (if/else) version of snap45
struct Uniforms {
  resolution: vec2<f32>,
  time: f32,
  threshold: f32,
  _pad: f32
};

@group(0) @binding(0)
var<uniform> uniforms : Uniforms;

fn snap45(v: vec2<f32>) -> vec2<f32> {
  let s = sign(v);
  let x = abs(v.x);
  if (x > 0.923880 * uniforms.threshold) {
    return vec2<f32>(s.x, 0.0);
  } else if (x > 0.382683 * uniforms.threshold) {
    return s * sqrt(0.5);
  } else {
    return vec2<f32>(0.0, s.y);
  }
}

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
  // Vertex Position Fix: full-screen triangle
  var pos = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -1.0),
    vec2<f32>( 3.0, -1.0),
    vec2<f32>(-1.0,  3.0)
  );
  return vec4<f32>(pos[vertexIndex], 0.0, 1.0);
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  // For visualization, compute a simple value from snap45.
  let uv = vec2<f32>(0.5); // fixed UV for demo purposes
  let v = uv * 2.0 - vec2<f32>(1.0);
  let result = snap45(v);
  let color = vec3<f32>(result.x * 0.5 + 0.5, result.y * 0.5 + 0.5, 0.0);
  return vec4<f32>(color, 1.0);
}
`;

    const defaultBranchlessWGSL = `
// Branchless shader (step + mix) version of snap45
struct Uniforms {
  resolution: vec2<f32>,
  time: f32,
  threshold: f32,
  _pad: f32
};

@group(0) @binding(0)
var<uniform> uniforms : Uniforms;

fn snap45(v: vec2<f32>) -> vec2<f32> {
  let s = sign(v);
  let x = abs(v.x);
  let w0 = step(0.92387953 * uniforms.threshold, x);
  let w1 = step(0.38268343 * uniforms.threshold, x) * (1.0 - w0);
  let w2 = 1.0 - w0 - w1;
  let res0 = vec2<f32>(s.x, 0.0);
  let res1 = vec2<f32>(s.x, s.y) * sqrt(0.5);
  let res2 = vec2<f32>(0.0, s.y);
  return w0 * res0 + w1 * res1 + w2 * res2;
}

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
  // Vertex Position Fix: full-screen triangle
  var pos = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -1.0),
    vec2<f32>( 3.0, -1.0),
    vec2<f32>(-1.0,  3.0)
  );
  return vec4<f32>(pos[vertexIndex], 0.0, 1.0);
}

@fragment
fn fs_main() -> @location(0) vec4<f32> {
  let uv = vec2<f32>(0.5); // fixed UV for demo purposes
  let v = uv * 2.0 - vec2<f32>(1.0);
  let result = snap45(v);
  let color = vec3<f32>(result.x * 0.5 + 0.5, result.y * 0.5 + 0.5, 0.0);
  return vec4<f32>(color, 1.0);
}
`;

    document.addEventListener("DOMContentLoaded", async () => {
      // Check WebGPU support.
      if (!navigator.gpu) {
        alert("WebGPU is not supported in this browser.");
        return;
      }
      
      // Initialize WebGPU adapter and device.
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();
      console.log("WebGPU device acquired.");
      
      // Initialize Ace editors.
      const branchEditor = initEditor("branchEditor", defaultBranchWGSL);
      const branchlessEditor = initEditor("branchlessEditor", defaultBranchlessWGSL);
      
      // Canvas setup.
      const [branchCanvas, branchlessCanvas] = initializeCanvases(
        ["branchCanvas", "branchlessCanvas"], device
      );
      
      // Uniform buffers (using 5 floats × 4 bytes = 20 bytes).
      const uniformBufferSize = 20;
      const branchUniformBuffer = createUniformBuffer(device, uniformBufferSize);
      const branchlessUniformBuffer = createUniformBuffer(device, uniformBufferSize);
      
      // Pipeline setup.
      const bindGroupLayout = createBindGroupLayout(device);
      const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
      });
      
      let [branchPipeline, branchlessPipeline] = await Promise.all([
        createPipeline(device, pipelineLayout, defaultBranchWGSL, branchCanvas.format),
        createPipeline(device, pipelineLayout, defaultBranchlessWGSL, branchlessCanvas.format)
      ]);
      
      // Threshold controls.
      const thresholdSlider = document.getElementById("thresholdSlider");
      let currentThreshold = parseFloat(thresholdSlider.value);
      thresholdSlider.addEventListener("input", updateThreshold);
      
      // Start render loops.
      startRenderLoop(device, branchCanvas, branchPipeline, branchUniformBuffer, "branchMetrics");
      startRenderLoop(device, branchlessCanvas, branchlessPipeline, branchlessUniformBuffer, "branchlessMetrics");
      
      // Compile button handlers.
      document.getElementById("compileBranch").addEventListener("click", () => 
        recompileShader(device, branchEditor, branchCanvas, pipelineLayout, "branch")
      );
      document.getElementById("compileBranchless").addEventListener("click", () => 
        recompileShader(device, branchlessEditor, branchlessCanvas, pipelineLayout, "branchless")
      );
      
      // --- Helper Functions ---
      
      // Initialize Ace Editor with default code.
      function initEditor(elementId, defaultCode) {
        const editor = ace.edit(elementId);
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/glsl");
        editor.setValue(defaultCode, -1);
        return editor;
      }
      
      // Set up canvases and configure their WebGPU contexts.
      function initializeCanvases(ids, device) {
        return ids.map(id => {
          const canvas = document.getElementById(id);
          canvas.width = canvas.clientWidth * devicePixelRatio;
          canvas.height = canvas.clientHeight * devicePixelRatio;
          const context = canvas.getContext("webgpu");
          const format = navigator.gpu.getPreferredCanvasFormat();
          context.configure({ device, format });
          return { canvas, context, format };
        });
      }
      
      // Create a render pipeline from WGSL code.
      async function createPipeline(device, layout, code, format) {
        try {
          return device.createRenderPipeline({
            layout,
            vertex: {
              module: device.createShaderModule({ code }),
              entryPoint: "vs_main"
            },
            fragment: {
              module: device.createShaderModule({ code }),
              entryPoint: "fs_main",
              targets: [{ format }]
            },
            primitive: { topology: "triangle-list" }
          });
        } catch (error) {
          console.error("Pipeline creation failed:", error);
          return null;
        }
      }
      
      // Render loop: update uniform, record commands, and schedule next frame.
      function startRenderLoop(device, canvasInfo, pipeline, uniformBuffer, metricsId) {
        const frameTimes = [];
        let lastTime = performance.now();
        
        function frame() {
          const now = performance.now();
          const delta = now - lastTime;
          lastTime = now;
          updateMetrics(metricsId, delta, frameTimes);
          updateUniformBuffer(device, uniformBuffer, canvasInfo.canvas, now);
          
          const commandEncoder = device.createCommandEncoder();
          const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [{
              view: canvasInfo.context.getCurrentTexture().createView(),
              clearValue: [0.1, 0.1, 0.1, 1],
              loadOp: "clear",
              storeOp: "store"
            }]
          });
          
          renderPass.setPipeline(pipeline);
          renderPass.setBindGroup(0, createBindGroup(device, bindGroupLayout, uniformBuffer));
          renderPass.draw(3);
          renderPass.end();
          
          device.queue.submit([commandEncoder.finish()]);
          requestAnimationFrame(frame);
        }
        
        requestAnimationFrame(frame);
      }
      
      // Update the threshold value from the slider.
      function updateThreshold(e) {
        currentThreshold = parseFloat(e.target.value);
        document.getElementById("thresholdValue").textContent = currentThreshold.toFixed(2);
      }
      
      // Update frame timing metrics.
      function updateMetrics(metricsId, delta, frameTimes) {
        frameTimes.push(delta);
        if (frameTimes.length > 100) frameTimes.shift();
        const avg = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
        const min = Math.min(...frameTimes);
        const max = Math.max(...frameTimes);
        document.getElementById(metricsId).textContent =
          `Frame Time (ms) – Avg: ${avg.toFixed(2)}, Min: ${min.toFixed(2)}, Max: ${max.toFixed(2)}`;
      }
      
      // Update the uniform buffer with current resolution, time, and threshold.
      function updateUniformBuffer(device, uniformBuffer, canvas, now) {
        const data = new Float32Array([
          canvas.width,
          canvas.height,
          now / 1000.0,
          currentThreshold,
          0.0  // Padding field (_pad)
        ]);
        device.queue.writeBuffer(uniformBuffer, 0, data.buffer, data.byteOffset, data.byteLength);
      }
      
      // Create a uniform buffer.
      function createUniformBuffer(device, size) {
        return device.createBuffer({
          size: size,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
      }
      
      // Create a bind group for the uniform buffer.
      function createBindGroup(device, bindGroupLayout, uniformBuffer) {
        return device.createBindGroup({
          layout: bindGroupLayout,
          entries: [{
            binding: 0,
            resource: { buffer: uniformBuffer }
          }]
        });
      }
      
      // Create a bind group layout.
      function createBindGroupLayout(device) {
        return device.createBindGroupLayout({
          entries: [{
            binding: 0,
            visibility: GPUShaderStage.FRAGMENT,
            buffer: { type: "uniform" }
          }]
        });
      }
      
      // Recompile shader from editor code and update the appropriate pipeline.
      async function recompileShader(device, editor, canvasInfo, pipelineLayout, type) {
        const code = editor.getValue();
        const newPipeline = await createPipeline(device, pipelineLayout, code, canvasInfo.format);
        if (newPipeline) {
          if (type === "branch") {
            branchPipeline = newPipeline;
            console.log("Branching shader recompiled successfully.");
          } else {
            branchlessPipeline = newPipeline;
            console.log("Branchless shader recompiled successfully.");
          }
        } else {
          alert("Failed to compile shader. Check console for errors.");
        }
      }
    });
  </script>
</body>
</html>
