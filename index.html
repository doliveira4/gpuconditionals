<!DOCTYPE html>
<html>
<head>
    <title>GPU Conditional Benchmark</title>
    <style>
        :root {
            --primary: #0ff;
            --background: #000;
            --text: #fff;
            --code-bg: #1a1a1a;
        }

        body {
            background: var(--background);
            color: var(--text);
            margin: 0;
            font-family: monospace;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            max-width: 800px;
        }

        .code-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        pre {
            background: var(--code-bg);
            padding: 15px;
            border-radius: 5px;
            white-space: pre-wrap;
        }

        button {
            background: #222;
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 8px 15px;
            cursor: pointer;
            margin-top: 10px;
        }

        #results {
            margin-top: 20px;
            padding: 15px;
            background: #111;
        }

        .benchmark-table {
            width: 100%;
            border-collapse: collapse;
        }

        .benchmark-table td, .benchmark-table th {
            padding: 8px;
            border: 1px solid #333;
            text-align: left;
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    
    <div id="controls">
        <div>
            <label>Conditional Type:
                <select id="conditionalType">
                    <option value="0">Branching (if/else)</option>
                    <option value="1">Branchless (math)</option>
                </select>
            </label>
            
            <label>Threshold: 
                <input type="range" id="threshold" min="0" max="1" step="0.01" value="0.5">
            </label>
            
            <button id="benchmarkButton">Run Benchmark (100 iterations)</button>
        </div>

        <div class="code-columns">
            <div>
                <h3>Branching Shader</h3>
                <pre>@fragment
fn main(...) -> ... {
    if uniforms.conditionalType == 0 {
        // Traditional branching
        if d < threshold {
            color = vec3(1,0,0);
        } else {
            color = vec3(0,0,1);
        }
    }
}</pre>
            </div>
            
            <div>
                <h3>Branchless Shader</h3>
                <pre>@fragment 
fn main(...) -> ... {
    // Mathematical approach
    let blend = step(threshold, d);
    color = mix(vec3(1,0,0), vec3(0,0,1), blend);
}</pre>
            </div>
        </div>

        <div id="results"></div>
    </div>

<script>
let benchmarkRunning = false;
const BENCHMARK_ITERATIONS = 100;

async function init() {
    const canvas = document.getElementById('mainCanvas');
    const device = await navigator.gpu.requestAdapter().then(a => a.requestDevice());
    const context = canvas.getContext('webgpu');
    const format = navigator.gpu.getPreferredCanvasFormat();
    
    canvas.width = 1024;
    canvas.height = 1024;
    context.configure({ device, format });

    // Shader setup
    const pipeline = device.createRenderPipeline({
        vertex: { 
            module: device.createShaderModule({
                code: `@vertex fn main(@builtin(vertex_index) vi: u32) -> @builtin(position) vec4<f32> {
                    const pos = array(vec2(-1,-1), vec2(3,-1), vec2(-1,3));
                    return vec4(pos[vi], 0, 1);
                }`
            })
        },
        fragment: {
            module: device.createShaderModule({
                code: document.querySelector('#fragmentShader').textContent
            }),
            targets: [{ format }]
        },
        layout: 'auto'
    });

    const uniformBuffer = device.createBuffer({
        size: 12,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });

    const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer: uniformBuffer }}]
    });

    // Benchmark functionality
    async function runBenchmark() {
        if(benchmarkRunning) return;
        benchmarkRunning = true;
        const benchmarkButton = document.getElementById('benchmarkButton');
        benchmarkButton.disabled = true;
        benchmarkButton.textContent = 'Running benchmark...';

        const results = {
            branching: [],
            branchless: []
        };

        // Run branching benchmark
        for(let i = 0; i < BENCHMARK_ITERATIONS; i++) {
            const start = performance.now();
            await renderFrame(0);
            results.branching.push(performance.now() - start);
        }

        // Run branchless benchmark
        for(let i = 0; i < BENCHMARK_ITERATIONS; i++) {
            const start = performance.now();
            await renderFrame(1);
            results.branchless.push(performance.now() - start);
        }

        showResults(results);
        benchmarkRunning = false;
        benchmarkButton.disabled = false;
        benchmarkButton.textContent = 'Run Benchmark (100 iterations)';
    }

    async function renderFrame(type) {
        const uniforms = new Float32Array([
            type,
            document.getElementById('threshold').value,
            performance.now() / 1000
        ]);
        
        device.queue.writeBuffer(uniformBuffer, 0, uniforms);
        
        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
            colorAttachments: [{
                view: context.getCurrentTexture().createView(),
                loadOp: 'clear',
                storeOp: 'store'
            }]
        });
        
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.draw(3);
        pass.end();
        
        const commandBuffer = encoder.finish();
        device.queue.submit([commandBuffer]);
        await device.queue.onSubmittedWorkDone();
    }

    function showResults(results) {
        const process = (arr) => ({
            avg: arr.reduce((a,b) => a + b, 0) / arr.length,
            min: Math.min(...arr),
            max: Math.max(...arr)
        });

        const branch = process(results.branching);
        const branchless = process(results.branchless);
        
        const diff = ((branchless.avg - branch.avg) / branch.avg * 100).toFixed(1);

        const resultHTML = `
            <h3>Benchmark Results (${BENCHMARK_ITERATIONS} iterations)</h3>
            <table class="benchmark-table">
                <tr>
                    <th>Metric</th>
                    <th>Branching</th>
                    <th>Branchless</th>
                    <th>Difference</th>
                </tr>
                <tr>
                    <td>Average</td>
                    <td>${branch.avg.toFixed(2)}ms</td>
                    <td>${branchless.avg.toFixed(2)}ms</td>
                    <td style="color: ${diff < 0 ? '#0f0' : '#f00'}">${diff}%</td>
                </tr>
                <tr>
                    <td>Minimum</td>
                    <td>${branch.min.toFixed(2)}ms</td>
                    <td>${branchless.min.toFixed(2)}ms</td>
                    <td></td>
                </tr>
                <tr>
                    <td>Maximum</td>
                    <td>${branch.max.toFixed(2)}ms</td>
                    <td>${branchless.max.toFixed(2)}ms</td>
                    <td></td>
                </tr>
            </table>
        `;

        document.getElementById('results').innerHTML = resultHTML;
    }

    // Event listeners
    document.getElementById('benchmarkButton').addEventListener('click', runBenchmark);

    // Initial render
    requestAnimationFrame(function frame() {
        renderFrame(document.getElementById('conditionalType').value);
        requestAnimationFrame(frame);
    });
}

init().catch(console.error);
</script>

<script id="fragmentShader" type="wgsl">
struct Uniforms {
    conditionalType: u32,
    threshold: f32,
    time: f32,
};

@group(0) @binding(0) var<uniform> uniforms: Uniforms;

@fragment
fn main(@builtin(position) coord: vec4<f32>) -> @location(0) vec4<f32> {
    let uv = coord.xy / 1024.0;
    let d = length(uv - vec2(0.5));
    let t = uniforms.time;
    let movingThreshold = uniforms.threshold * (0.5 + 0.5*sin(t));
    
    var color = vec3(0.0);
    
    if uniforms.conditionalType == 0 {
        if d < movingThreshold {
            color = vec3(1.0, 0.0, 0.0);
        } else {
            color = vec3(0.0, 0.0, 1.0);
        }
    } else {
        let blend = step(movingThreshold, d);
        color = mix(vec3(1.0,0.0,0.0), vec3(0.0,0.0,1.0), blend);
    }
    
    return vec4(color, 1.0);
}
</script>
</body>
</html>
