<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Conditional Benchmark</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet">
    <style>
        :root {
            --primary: #0ff;
            --background: #000;
            --text: #fff;
            --code-bg: #1a1a1a;
        }

        body {
            background: var(--background);
            color: var(--text);
            margin: 0;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        #controls {
            padding: 20px;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .code-columns {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 15px;
        }

        .code-column {
            flex: 1 1 400px;
        }

        pre[class*="language-"] {
            background: var(--code-bg);
            padding: 15px;
            border-radius: 5px;
            margin: 0;
            height: 400px;
            overflow: auto;
        }

        button {
            background: #222;
            color: var(--primary);
            border: 1px solid var(--primary);
            padding: 8px 15px;
            cursor: pointer;
            margin: 10px 0;
        }

        canvas {
            width: 100%;
            height: 40vh;
        }

        #results {
            margin-top: 20px;
            padding: 15px;
            background: #111;
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <div id="controls">
        <button id="benchmarkButton">Run Benchmark (100 iterations)</button>
        
        <div class="code-columns">
            <div class="code-column">
                <h3>Branching Shader</h3>
                <pre><code class="language-glsl" id="branchingShader">
#version 300 es
precision highp float;

uniform float u_time;
out vec4 fragColor;

void main() {
    vec2 uv = gl_FragCoord.xy / vec2(1024.0);
    float d = length(uv - vec2(0.5));
    float threshold = 0.5 * (1.0 + sin(u_time));
    
    vec3 color;
    if (d < threshold) {
        color = vec3(1.0, 0.0, 0.0);
    } else {
        color = vec3(0.0, 0.0, 1.0);
    }
    
    fragColor = vec4(color, 1.0);
}
                </code></pre>
            </div>
            
            <div class="code-column">
                <h3>Branchless Shader</h3>
                <pre><code class="language-glsl" id="branchlessShader">
#version 300 es
precision highp float;

uniform float u_time;
out vec4 fragColor;

void main() {
    vec2 uv = gl_FragCoord.xy / vec2(1024.0);
    float d = length(uv - vec2(0.5));
    float threshold = 0.5 * (1.0 + sin(u_time));
    
    float blend = step(threshold, d);
    vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), blend);
    
    fragColor = vec4(color, 1.0);
}
                </code></pre>
            </div>
        </div>

        <div id="results"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-glsl.min.js"></script>
    <script>
    let gl;
    let branchingProgram, branchlessProgram;
    let timeLocation;
    const BENCHMARK_ITERATIONS = 100;

    async function init() {
        const canvas = document.getElementById('mainCanvas');
        gl = canvas.getContext('webgl2');
        if (!gl) {
            alert('WebGL 2 not supported');
            return;
        }

        branchingProgram = createProgram(gl, 'branchingShader');
        branchlessProgram = createProgram(gl, 'branchlessShader');

        timeLocation = gl.getUniformLocation(branchingProgram, 'u_time');

        document.getElementById('benchmarkButton').addEventListener('click', runBenchmark);

        requestAnimationFrame(render);
    }

    function createProgram(gl, shaderId) {
        const vsSource = `#version 300 es
        in vec4 a_position;
        void main() {
            gl_Position = a_position;
        }`;

        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, vsSource);
        gl.compileShader(vs);

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, document.getElementById(shaderId).textContent);
        gl.compileShader(fs);

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Shader program failed to link:', gl.getProgramInfoLog(program));
            return null;
        }

        return program;
    }

    function render(time) {
        time *= 0.001;  // Convert to seconds

        gl.useProgram(branchingProgram);
        gl.uniform1f(timeLocation, time);

        gl.drawArrays(gl.TRIANGLES, 0, 3);

        requestAnimationFrame(render);
    }

    async function runBenchmark() {
        const results = {
            branching: [],
            branchless: []
        };

        for (let i = 0; i < BENCHMARK_ITERATIONS; i++) {
            results.branching.push(await measurePerformance(branchingProgram));
            results.branchless.push(await measurePerformance(branchlessProgram));
        }

        displayResults(results);
    }

    async function measurePerformance(program) {
        return new Promise(resolve => {
            gl.useProgram(program);
            const startTime = performance.now();
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            gl.finish();
            const endTime = performance.now();
            resolve(endTime - startTime);
        });
    }

    function displayResults(results) {
        const avgBranching = results.branching.reduce((a, b) => a + b) / BENCHMARK_ITERATIONS;
        const avgBranchless = results.branchless.reduce((a, b) => a + b) / BENCHMARK_ITERATIONS;

        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = `
            <h3>Benchmark Results (${BENCHMARK_ITERATIONS} iterations)</h3>
            <p>Branching: ${avgBranching.toFixed(3)} ms</p>
            <p>Branchless: ${avgBranchless.toFixed(3)} ms</p>
            <p>Difference: ${((avgBranchless - avgBranching) / avgBranching * 100).toFixed(2)}%</p>
        `;
    }

    init();
    Prism.highlightAll();
    </script>
</body>
</html>
