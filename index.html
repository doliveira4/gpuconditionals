<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GPU Conditionals Demo</title>
  <style>
    /* Make the canvas fill the entire window */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      height: 100%;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <!-- A single canvas element for WebGL output -->
  <canvas id="glcanvas"></canvas>
  <script>
    // Get the canvas and set its dimensions
    const canvas = document.getElementById('glcanvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Initialize WebGL
    const gl = canvas.getContext('webgl');
    if (!gl) {
      alert("WebGL not supported in your browser");
      throw new Error("WebGL not supported");
    }

    // Vertex shader – simply passes through vertex positions.
    const vsSource = `
      attribute vec2 a_position;
      void main(void) {
        // a_position is in clip-space already (range -1 to 1)
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    // Fragment shader – demonstrates a GPU conditional.
    // It computes a dynamic radius (oscillating with time) and colors each fragment
    // based on whether its distance to the center is less than the radius.
    const fsSource = `
      precision mediump float;
      uniform vec2 u_resolution;
      uniform float u_time;
      void main(void) {
        // Normalize pixel coordinates (0.0 - 1.0)
        vec2 st = gl_FragCoord.xy / u_resolution;
        
        // Center coordinate of the screen
        vec2 center = vec2(0.5, 0.5);
        
        // Compute the distance from the current fragment to the center
        float dist = distance(st, center);
        
        // Create a dynamic radius that oscillates with time
        float radius = 0.3 + 0.1 * sin(u_time);
        
        vec3 color;
        // GPU conditional: branch based on distance from the center.
        if (dist < radius) {
          // Inside the dynamic circle – use a warm gradient.
          color = mix(vec3(1.0, 0.8, 0.2), vec3(1.0, 0.5, 0.0), dist / radius);
        } else {
          // Outside the circle – use a cool background gradient.
          color = mix(vec3(0.0, 0.2, 0.4), vec3(0.0, 0.0, 0.2), st.y);
        }
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    // Helper function to compile a shader.
    function compileShader(gl, source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const error = gl.getShaderInfoLog(shader);
        console.error('Error compiling shader:', error);
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    // Compile the vertex and fragment shaders.
    const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
    const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);

    // Create and link the WebGL program.
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Error linking program:', gl.getProgramInfoLog(program));
      throw new Error('Program link failed');
    }

    // Look up locations of attributes and uniforms.
    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
    const timeLocation = gl.getUniformLocation(program, 'u_time');

    // Create a buffer and put a rectangle covering clip space.
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    // Two triangles that form a rectangle covering the entire canvas.
    const positions = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
      -1,  1,
       1, -1,
       1,  1,
    ]);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    // Main render loop
    let startTime = null;
    function render(time) {
      if (!startTime) startTime = time;
      const elapsedTime = (time - startTime) / 1000.0; // Convert to seconds

      // Adjust the viewport and clear the canvas.
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      // Use the compiled shader program.
      gl.useProgram(program);

      // Set the resolution and time uniforms.
      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(timeLocation, elapsedTime);

      // Enable the vertex attribute.
      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      // Draw the rectangle.
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Request the next frame.
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);

    // Update canvas size on window resize.
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    });
  </script>
</body>
</html>
