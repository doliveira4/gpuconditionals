<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GPU Conditionals Benchmark – snap45 Comparison</title>
  <!-- Ace Editor (from CDN) for syntax highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.14/ace.js" integrity="sha512-oRz6wK1oP5w8XaxJPmJYr++4jvtphKwLEdi+EbtxmH7cWFUhy9bWlL4RcpXqL7kBUHd21SkB98uP3imW6v9EXg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    /* Reset and basic styling */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: sans-serif;
      background: #111;
      color: #ddd;
    }
    /* Use flex layout so that header, main and footer are always visible */
    body {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    /* Top control bar */
    #controls {
      flex: 0 0 50px;
      background-color: #222;
      padding: 10px;
      display: flex;
      align-items: center;
    }
    #controls label,
    #controls input {
      margin-right: 10px;
    }
    /* Main container for the two panels */
    #container {
      flex: 1;
      display: flex;
      flex-wrap: wrap;
      overflow: auto;
    }
    .panel {
      flex: 1 1 50%;
      box-sizing: border-box;
      padding: 10px;
      border: 1px solid #444;
      display: flex;
      flex-direction: column;
      min-width: 300px;
    }
    .panel h2 {
      margin: 0 0 5px;
      font-size: 1.1em;
    }
    /* Ace Editor container styling */
    .editor {
      width: 100%;
      height: 200px;
      border: 1px solid #555;
      margin-bottom: 5px;
    }
    .panel button {
      margin-bottom: 5px;
      padding: 5px 10px;
      background: #444;
      color: #ddd;
      border: none;
      cursor: pointer;
    }
    .panel button:hover {
      background: #555;
    }
    .panel canvas {
      flex: 1;
      width: 100%;
      background-color: #000;
      border: 1px solid #444;
      margin-top: 5px;
    }
    .metrics {
      margin-top: 5px;
      font-size: 0.9em;
    }
    /* Footer: a dedicated bottom bar for Buy Me A Coffee */
    #footer {
      flex: 0 0 60px;
      background-color: #222;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #footer a img {
      height: 60px;
      width: auto;
    }
  </style>
</head>
<body>
  <!-- Top control bar -->
  <div id="controls">
    <label for="thresholdSlider">Threshold:</label>
    <input type="range" id="thresholdSlider" min="0.1" max="2.0" step="0.01" value="1.0">
    <span id="thresholdValue">1.00</span>
  </div>

  <!-- Main container with two panels -->
  <div id="container">
    <!-- Branching version panel -->
    <div class="panel">
      <h2>Branching Shader (if/else)</h2>
      <div id="branchEditor" class="editor"></div>
      <button id="compileBranch">Compile Branching Shader</button>
      <canvas id="branchCanvas"></canvas>
      <div class="metrics" id="branchMetrics">Frame Time: N/A</div>
    </div>
    <!-- Branchless version panel -->
    <div class="panel">
      <h2>Branchless Shader (step + mix)</h2>
      <div id="branchlessEditor" class="editor"></div>
      <button id="compileBranchless">Compile Branchless Shader</button>
      <canvas id="branchlessCanvas"></canvas>
      <div class="metrics" id="branchlessMetrics">Frame Time: N/A</div>
    </div>
  </div>

  <!-- Footer with Buy Me A Coffee button -->
  <div id="footer">
    <a href="https://buymeacoffee.com/doliveira4" target="_blank">
      <img src="https://cdn.buymeacoffee.com/buttons/v2/default-blue.png" alt="Buy Me A Coffee">
    </a>
  </div>

  <!-- Main Script: sets up WebGPU, editors, pipelines, UI, and render loops -->
  <script type="module">
    // Ensure the browser supports WebGPU.
    if (!navigator.gpu) {
      alert("WebGPU is not supported in this browser.");
      throw new Error("WebGPU not supported");
    }
    
    // --- Default WGSL Code for Each Strategy ---
    const defaultBranchWGSL = `// Branching shader (if/else) version of snap45
struct Uniforms {
  resolution: vec2<f32>,
  time: f32,
  threshold: f32,
};

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

fn snap45(v: vec2<f32>) -> vec2<f32> {
  let s = sign(v);
  let x = abs(v.x);
  if (x > 0.923880 * uniforms.threshold) {
    return vec2<f32>(s.x, 0.0);
  } else if (x > 0.382683 * uniforms.threshold) {
    return s * sqrt(0.5);
  } else {
    return vec2<f32>(0.0, s.y);
  }
}

struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) fragUV: vec2<f32>,
};

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
  var pos = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -3.0),
    vec2<f32>( 3.0,  1.0),
    vec2<f32>(-1.0,  1.0)
  );
  var output: VertexOutput;
  output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
  output.fragUV = (pos[vertexIndex] + vec2<f32>(1.0, 1.0)) * 0.5;
  return output;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
  let uv = in.fragUV;
  let v = uv * 2.0 - vec2<f32>(1.0, 1.0);
  let result = snap45(v);
  let color = vec3<f32>(result.x * 0.5 + 0.5, result.y * 0.5 + 0.5, 0.0);
  return vec4<f32>(color, 1.0);
}
`;

    const defaultBranchlessWGSL = `// Branchless shader (step + mix) version of snap45
struct Uniforms {
  resolution: vec2<f32>,
  time: f32,
  threshold: f32,
};

@group(0) @binding(0)
var<uniform> uniforms: Uniforms;

fn snap45(v: vec2<f32>) -> vec2<f32> {
  let s = sign(v);
  let x = abs(v.x);
  let w0 = step(0.92387953 * uniforms.threshold, x);
  let w1 = step(0.38268343 * uniforms.threshold, x) * (1.0 - w0);
  let w2 = 1.0 - w0 - w1;
  let res0 = vec2<f32>(s.x, 0.0);
  let res1 = vec2<f32>(s.x, s.y) * sqrt(0.5);
  let res2 = vec2<f32>(0.0, s.y);
  return w0 * res0 + w1 * res1 + w2 * res2;
}

struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) fragUV: vec2<f32>,
};

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
  var pos = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -3.0),
    vec2<f32>( 3.0,  1.0),
    vec2<f32>(-1.0,  1.0)
  );
  var output: VertexOutput;
  output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
  output.fragUV = (pos[vertexIndex] + vec2<f32>(1.0, 1.0)) * 0.5;
  return output;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
  let uv = in.fragUV;
  let v = uv * 2.0 - vec2<f32>(1.0, 1.0);
  let result = snap45(v);
  let color = vec3<f32>(result.x * 0.5 + 0.5, result.y * 0.5 + 0.5, 0.0);
  return vec4<f32>(color, 1.0);
}
`;

    // --- Initialize Ace Editors for Syntax Highlighting ---
    const branchEditor = ace.edit("branchEditor");
    branchEditor.setTheme("ace/theme/monokai");
    branchEditor.session.setMode("ace/mode/glsl");
    branchEditor.setValue(defaultBranchWGSL, -1);

    const branchlessEditor = ace.edit("branchlessEditor");
    branchlessEditor.setTheme("ace/theme/monokai");
    branchlessEditor.session.setMode("ace/mode/glsl");
    branchlessEditor.setValue(defaultBranchlessWGSL, -1);

    // --- Canvas and Context Setup ---
    const branchCanvas = document.getElementById("branchCanvas");
    const branchlessCanvas = document.getElementById("branchlessCanvas");

    function initCanvas(canvas) {
      const context = canvas.getContext("webgpu");
      // Set the drawing buffer size based on CSS dimensions.
      canvas.width = canvas.clientWidth * (window.devicePixelRatio || 1);
      canvas.height = canvas.clientHeight * (window.devicePixelRatio || 1);
      const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
      context.configure({
        device: device,
        format: presentationFormat,
        alphaMode: "premultiplied"
      });
      return { context, presentationFormat };
    }
    const branchSetup = initCanvas(branchCanvas);
    const branchlessSetup = initCanvas(branchlessCanvas);

    // --- Uniform Buffer and Bind Groups ---
    const uniformBufferSize = 4 * 4;
    function createUniformBuffer() {
      return device.createBuffer({
        size: uniformBufferSize,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });
    }
    const branchUniformBuffer = createUniformBuffer();
    const branchlessUniformBuffer = createUniformBuffer();

    const bindGroupLayout = device.createBindGroupLayout({
      entries: [{
        binding: 0,
        visibility: GPUShaderStage.FRAGMENT,
        buffer: { type: "uniform" }
      }]
    });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    function createBindGroup(uniformBuffer) {
      return device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: { buffer: uniformBuffer }
        }]
      });
    }
    let branchBindGroup = createBindGroup(branchUniformBuffer);
    let branchlessBindGroup = createBindGroup(branchlessUniformBuffer);

    // --- Pipeline Creation ---
    function createPipeline(shaderCode, presentationFormat) {
      const shaderModule = device.createShaderModule({ code: shaderCode });
      try {
        const pipeline = device.createRenderPipeline({
          layout: pipelineLayout,
          vertex: {
            module: shaderModule,
            entryPoint: "vs_main",
          },
          fragment: {
            module: shaderModule,
            entryPoint: "fs_main",
            targets: [{ format: presentationFormat }]
          },
          primitive: { topology: "triangle-list" }
        });
        return pipeline;
      } catch (e) {
        console.error("Pipeline creation error:", e);
        return null;
      }
    }
    let branchPipeline = createPipeline(defaultBranchWGSL, branchSetup.presentationFormat);
    let branchlessPipeline = createPipeline(defaultBranchlessWGSL, branchlessSetup.presentationFormat);

    // --- Shared Parameter: Threshold ---
    const thresholdSlider = document.getElementById("thresholdSlider");
    let currentThreshold = parseFloat(thresholdSlider.value);
    thresholdSlider.addEventListener("input", (e) => {
      currentThreshold = parseFloat(e.target.value);
      document.getElementById("thresholdValue").textContent = currentThreshold.toFixed(2);
    });

    // --- Performance Metrics ---
    const branchFrameTimes = [];
    const branchlessFrameTimes = [];
    const branchMetricsEl = document.getElementById("branchMetrics");
    const branchlessMetricsEl = document.getElementById("branchlessMetrics");
    function updateMetrics(el, frameTimes) {
      if (frameTimes.length === 0) return;
      const sum = frameTimes.reduce((a, b) => a + b, 0);
      const avg = sum / frameTimes.length;
      const min = Math.min(...frameTimes);
      const max = Math.max(...frameTimes);
      el.textContent = `Frame Time (ms) – Avg: ${avg.toFixed(2)}, Min: ${min.toFixed(2)}, Max: ${max.toFixed(2)}`;
    }

    // --- Render Loop for Branching Shader ---
    let branchLastTime = performance.now();
    function renderBranch() {
      const now = performance.now();
      const delta = now - branchLastTime;
      branchLastTime = now;
      branchFrameTimes.push(delta);
      if (branchFrameTimes.length > 100) branchFrameTimes.shift();
      updateMetrics(branchMetricsEl, branchFrameTimes);
      const uniformData = new Float32Array([
        branchCanvas.width,
        branchCanvas.height,
        (now % 100000) / 1000.0,
        currentThreshold
      ]);
      device.queue.writeBuffer(branchUniformBuffer, 0, uniformData.buffer);
      const commandEncoder = device.createCommandEncoder();
      const textureView = branchSetup.context.getCurrentTexture().createView();
      const renderPass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: textureView,
          loadOp: 'clear',
          storeOp: 'store',
          clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 }
        }]
      });
      renderPass.setPipeline(branchPipeline);
      renderPass.setBindGroup(0, branchBindGroup);
      renderPass.draw(3, 1, 0, 0);
      renderPass.end();
      device.queue.submit([commandEncoder.finish()]);
      requestAnimationFrame(renderBranch);
    }

    // --- Render Loop for Branchless Shader ---
    let branchlessLastTime = performance.now();
    function renderBranchless() {
      const now = performance.now();
      const delta = now - branchlessLastTime;
      branchlessLastTime = now;
      branchlessFrameTimes.push(delta);
      if (branchlessFrameTimes.length > 100) branchlessFrameTimes.shift();
      updateMetrics(branchlessMetricsEl, branchlessFrameTimes);
      const uniformData = new Float32Array([
        branchlessCanvas.width,
        branchlessCanvas.height,
        (now % 100000) / 1000.0,
        currentThreshold
      ]);
      device.queue.writeBuffer(branchlessUniformBuffer, 0, uniformData.buffer);
      const commandEncoder = device.createCommandEncoder();
      const textureView = branchlessSetup.context.getCurrentTexture().createView();
      const renderPass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: textureView,
          loadOp: 'clear',
          storeOp: 'store',
          clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 }
        }]
      });
      renderPass.setPipeline(branchlessPipeline);
      renderPass.setBindGroup(0, branchlessBindGroup);
      renderPass.draw(3, 1, 0, 0);
      renderPass.end();
      device.queue.submit([commandEncoder.finish()]);
      requestAnimationFrame(renderBranchless);
    }

    renderBranch();
    renderBranchless();

    // --- Recompile on Demand ---
    document.getElementById("compileBranch").addEventListener("click", () => {
      const code = branchEditor.getValue();
      const newPipeline = createPipeline(code, branchSetup.presentationFormat);
      if (newPipeline) {
        branchPipeline = newPipeline;
        console.log("Branching shader recompiled successfully.");
      } else {
        alert("Failed to compile branching shader. Check the console for errors.");
      }
    });
    document.getElementById("compileBranchless").addEventListener("click", () => {
      const code = branchlessEditor.getValue();
      const newPipeline = createPipeline(code, branchlessSetup.presentationFormat);
      if (newPipeline) {
        branchlessPipeline = newPipeline;
        console.log("Branchless shader recompiled successfully.");
      } else {
        alert("Failed to compile branchless shader. Check the console for errors.");
      }
    });

    // Handle window resize.
    window.addEventListener("resize", () => {
      [branchCanvas, branchlessCanvas].forEach(canvas => {
        canvas.width = canvas.clientWidth * (window.devicePixelRatio || 1);
        canvas.height = canvas.clientHeight * (window.devicePixelRatio || 1);
      });
    });
  </script>
</body>
</html>
