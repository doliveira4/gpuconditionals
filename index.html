<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GPU Conditionals Benchmark – Branching vs. Branchless</title>
  <style>
    /* Basic reset and layout */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: sans-serif;
      background: #111;
      color: #ddd;
    }
    /* Top controls */
    #controls {
      padding: 10px;
      background-color: #222;
      display: flex;
      align-items: center;
    }
    #controls label,
    #controls input {
      margin-right: 10px;
    }
    /* Main container for two panels */
    #container {
      display: flex;
      flex-wrap: wrap;
      height: calc(100% - 50px);
    }
    .panel {
      flex: 1 1 50%;
      box-sizing: border-box;
      padding: 10px;
      border: 1px solid #444;
      display: flex;
      flex-direction: column;
    }
    .panel h2 {
      margin: 0 0 5px;
      font-size: 1.1em;
    }
    .panel textarea {
      width: 100%;
      box-sizing: border-box;
      font-family: monospace;
      font-size: 0.9em;
      margin-bottom: 5px;
      resize: vertical;
      height: 150px;
      background: #222;
      color: #ddd;
      border: 1px solid #555;
      padding: 5px;
    }
    .panel button {
      margin-bottom: 5px;
      padding: 5px 10px;
      background: #444;
      color: #ddd;
      border: none;
      cursor: pointer;
    }
    .panel button:hover {
      background: #555;
    }
    .panel canvas {
      flex: 1;
      width: 100%;
      background-color: #000;
      border: 1px solid #444;
    }
    .metrics {
      margin-top: 5px;
      font-size: 0.9em;
    }
  </style>
</head>
<body>
  <!-- Shared control: adjust the threshold uniform -->
  <div id="controls">
    <label for="thresholdSlider">Threshold:</label>
    <input type="range" id="thresholdSlider" min="0" max="1" step="0.01" value="0.5">
    <span id="thresholdValue">0.50</span>
  </div>

  <!-- Two panels: one per shader strategy -->
  <div id="container">
    <!-- Panel for the Branching (if/else) shader -->
    <div class="panel">
      <h2>Branching Shader (if/else)</h2>
      <textarea id="branchEditor"></textarea>
      <button id="compileBranch">Compile Branching Shader</button>
      <canvas id="branchCanvas"></canvas>
      <div class="metrics" id="branchMetrics">Frame Time: N/A</div>
    </div>

    <!-- Panel for the Branchless (step + mix) shader -->
    <div class="panel">
      <h2>Branchless Shader (step + mix)</h2>
      <textarea id="branchlessEditor"></textarea>
      <button id="compileBranchless">Compile Branchless Shader</button>
      <canvas id="branchlessCanvas"></canvas>
      <div class="metrics" id="branchlessMetrics">Frame Time: N/A</div>
    </div>
  </div>

  <!-- Main script: initializes WebGPU, creates pipelines, and starts render loops -->
  <script type="module">
    // Check for WebGPU support.
    if (!navigator.gpu) {
      alert("WebGPU is not supported in this browser.");
      throw new Error("WebGPU not supported");
    }

    // Top-level async initialization.
    (async () => {
      // Request the GPU adapter and device.
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();

      // --- Common Vertex Shader (WGSL) ---
      const vertexWGSL = `// Full-screen triangle vertex shader
struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) fragUV : vec2<f32>,
};

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
  var pos = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -3.0),
    vec2<f32>( 3.0,  1.0),
    vec2<f32>(-1.0,  1.0)
  );
  var output : VertexOutput;
  output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
  // Map from clip space to UV coordinates (0..1)
  output.fragUV = (pos[vertexIndex] + vec2<f32>(1.0, 1.0)) * 0.5;
  return output;
}
`;

      // --- Default WGSL code for each strategy ---
      const defaultBranchWGSL = `// Branching shader (if/else)
struct Uniforms {
  resolution: vec2<f32>,
  time: f32,
  threshold: f32,
};

@group(0) @binding(0)
var<uniform> uniforms : Uniforms;

struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) fragUV : vec2<f32>,
};

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
  var pos = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -3.0),
    vec2<f32>( 3.0,  1.0),
    vec2<f32>(-1.0,  1.0)
  );
  var output : VertexOutput;
  output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
  output.fragUV = (pos[vertexIndex] + vec2<f32>(1.0,1.0)) * 0.5;
  return output;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
  let d = distance(in.fragUV, vec2<f32>(0.5, 0.5));
  var color: vec3<f32>;
  if (d < uniforms.threshold) {
    color = vec3<f32>(1.0, 0.0, 0.0);
  } else {
    color = vec3<f32>(0.0, 0.0, 1.0);
  }
  return vec4<f32>(color, 1.0);
}
`;

      const defaultBranchlessWGSL = `// Branchless shader (step + mix)
struct Uniforms {
  resolution: vec2<f32>,
  time: f32,
  threshold: f32,
};

@group(0) @binding(0)
var<uniform> uniforms : Uniforms;

struct VertexOutput {
  @builtin(position) position : vec4<f32>,
  @location(0) fragUV : vec2<f32>,
};

@vertex
fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
  var pos = array<vec2<f32>, 3>(
    vec2<f32>(-1.0, -3.0),
    vec2<f32>( 3.0,  1.0),
    vec2<f32>(-1.0,  1.0)
  );
  var output : VertexOutput;
  output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
  output.fragUV = (pos[vertexIndex] + vec2<f32>(1.0,1.0)) * 0.5;
  return output;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
  let d = distance(in.fragUV, vec2<f32>(0.5, 0.5));
  let t = step(d, uniforms.threshold);
  let color = vec3<f32>(0.0, 0.0, 1.0) + (vec3<f32>(1.0, 0.0, 0.0) - vec3<f32>(0.0, 0.0, 1.0)) * t;
  return vec4<f32>(color, 1.0);
}
`;

      // Set the default code into each editor.
      document.getElementById("branchEditor").value = defaultBranchWGSL;
      document.getElementById("branchlessEditor").value = defaultBranchlessWGSL;

      // --- Canvas & Context Setup ---
      const branchCanvas = document.getElementById("branchCanvas");
      const branchlessCanvas = document.getElementById("branchlessCanvas");

      // A helper to initialize a canvas with a WebGPU context.
      function initCanvas(canvas) {
        const context = canvas.getContext("webgpu");
        // Set canvas CSS size first then update its drawing buffer size.
        canvas.width = canvas.clientWidth * (window.devicePixelRatio || 1);
        canvas.height = canvas.clientHeight * (window.devicePixelRatio || 1);
        const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: presentationFormat,
          alphaMode: "premultiplied"
        });
        return { context, presentationFormat };
      }
      const branchSetup = initCanvas(branchCanvas);
      const branchlessSetup = initCanvas(branchlessCanvas);

      // --- Uniform Buffer & Bind Group ---
      // Our uniform struct contains 4 float32 values:
      //   vec2<f32> resolution, f32 time, f32 threshold (16 bytes total)
      const uniformBufferSize = 4 * 4;
      function createUniformBuffer() {
        return device.createBuffer({
          size: uniformBufferSize,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
      }
      const branchUniformBuffer = createUniformBuffer();
      const branchlessUniformBuffer = createUniformBuffer();

      // Create a bind group layout and pipeline layout.
      const bindGroupLayout = device.createBindGroupLayout({
        entries: [{
          binding: 0,
          visibility: GPUShaderStage.FRAGMENT,
          buffer: { type: "uniform" }
        }]
      });
      const pipelineLayout = device.createPipelineLayout({
        bindGroupLayouts: [bindGroupLayout]
      });
      // Create bind groups using the uniform buffers.
      function createBindGroup(uniformBuffer) {
        return device.createBindGroup({
          layout: bindGroupLayout,
          entries: [{
            binding: 0,
            resource: { buffer: uniformBuffer }
          }]
        });
      }
      let branchBindGroup = createBindGroup(branchUniformBuffer);
      let branchlessBindGroup = createBindGroup(branchlessUniformBuffer);

      // --- Pipeline Creation Function ---
      // Given WGSL code for the fragment shader and the canvas format, create a pipeline.
      function createPipeline(fragmentWGSL, presentationFormat) {
        const shaderModuleFragment = device.createShaderModule({ code: fragmentWGSL });
        const shaderModuleVertex = device.createShaderModule({ code: vertexWGSL });
        try {
          const pipeline = device.createRenderPipeline({
            layout: pipelineLayout,
            vertex: {
              module: shaderModuleVertex,
              entryPoint: "vs_main",
            },
            fragment: {
              module: shaderModuleFragment,
              entryPoint: "fs_main",
              targets: [{ format: presentationFormat }]
            },
            primitive: { topology: "triangle-list" }
          });
          return pipeline;
        } catch (e) {
          console.error("Pipeline creation error:", e);
          return null;
        }
      }
      // Create the initial pipelines from the default WGSL code.
      let branchPipeline = createPipeline(defaultBranchWGSL, branchSetup.presentationFormat);
      let branchlessPipeline = createPipeline(defaultBranchlessWGSL, branchlessSetup.presentationFormat);

      // --- Shared Parameter: Threshold ---
      const thresholdSlider = document.getElementById("thresholdSlider");
      let currentThreshold = parseFloat(thresholdSlider.value);
      thresholdSlider.addEventListener("input", (e) => {
        currentThreshold = parseFloat(e.target.value);
        document.getElementById("thresholdValue").textContent = currentThreshold.toFixed(2);
      });

      // --- Performance Metrics ---
      // Arrays to store the last 100 frame times for each render loop.
      const branchFrameTimes = [];
      const branchlessFrameTimes = [];
      const branchMetricsEl = document.getElementById("branchMetrics");
      const branchlessMetricsEl = document.getElementById("branchlessMetrics");
      function updateMetrics(el, frameTimes) {
        if (frameTimes.length === 0) return;
        const sum = frameTimes.reduce((a, b) => a + b, 0);
        const avg = sum / frameTimes.length;
        const min = Math.min(...frameTimes);
        const max = Math.max(...frameTimes);
        el.textContent = `Frame Time (ms) – Avg: ${avg.toFixed(2)}, Min: ${min.toFixed(2)}, Max: ${max.toFixed(2)}`;
      }

      // --- Render Loop for Branching Shader ---
      let branchLastTime = performance.now();
      function renderBranch() {
        const now = performance.now();
        const delta = now - branchLastTime;
        branchLastTime = now;
        branchFrameTimes.push(delta);
        if (branchFrameTimes.length > 100) branchFrameTimes.shift();
        updateMetrics(branchMetricsEl, branchFrameTimes);
        // Update uniform buffer: [resolution.x, resolution.y, time, threshold]
        const uniformData = new Float32Array([
          branchCanvas.width,
          branchCanvas.height,
          (now % 100000) / 1000.0,
          currentThreshold
        ]);
        device.queue.writeBuffer(branchUniformBuffer, 0, uniformData.buffer);
        // Begin rendering.
        const commandEncoder = device.createCommandEncoder();
        const textureView = branchSetup.context.getCurrentTexture().createView();
        const renderPass = commandEncoder.beginRenderPass({
          colorAttachments: [{
            view: textureView,
            loadOp: 'clear',
            storeOp: 'store',
            clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 }
          }]
        });
        renderPass.setPipeline(branchPipeline);
        renderPass.setBindGroup(0, branchBindGroup);
        renderPass.draw(3, 1, 0, 0);
        renderPass.end();
        device.queue.submit([commandEncoder.finish()]);
        requestAnimationFrame(renderBranch);
      }

      // --- Render Loop for Branchless Shader ---
      let branchlessLastTime = performance.now();
      function renderBranchless() {
        const now = performance.now();
        const delta = now - branchlessLastTime;
        branchlessLastTime = now;
        branchlessFrameTimes.push(delta);
        if (branchlessFrameTimes.length > 100) branchlessFrameTimes.shift();
        updateMetrics(branchlessMetricsEl, branchlessFrameTimes);
        // Update uniform buffer.
        const uniformData = new Float32Array([
          branchlessCanvas.width,
          branchlessCanvas.height,
          (now % 100000) / 1000.0,
          currentThreshold
        ]);
        device.queue.writeBuffer(branchlessUniformBuffer, 0, uniformData.buffer);
        // Render.
        const commandEncoder = device.createCommandEncoder();
        const textureView = branchlessSetup.context.getCurrentTexture().createView();
        const renderPass = commandEncoder.beginRenderPass({
          colorAttachments: [{
            view: textureView,
            loadOp: 'clear',
            storeOp: 'store',
            clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 }
          }]
        });
        renderPass.setPipeline(branchlessPipeline);
        renderPass.setBindGroup(0, branchlessBindGroup);
        renderPass.draw(3, 1, 0, 0);
        renderPass.end();
        device.queue.submit([commandEncoder.finish()]);
        requestAnimationFrame(renderBranchless);
      }

      // Start the continuous render loops.
      renderBranch();
      renderBranchless();

      // --- Recompile on Demand ---
      document.getElementById("compileBranch").addEventListener("click", () => {
        const code = document.getElementById("branchEditor").value;
        const newPipeline = createPipeline(code, branchSetup.presentationFormat);
        if (newPipeline) {
          branchPipeline = newPipeline;
          console.log("Branching shader recompiled successfully.");
        } else {
          alert("Failed to compile branching shader. Check the console for errors.");
        }
      });
      document.getElementById("compileBranchless").addEventListener("click", () => {
        const code = document.getElementById("branchlessEditor").value;
        const newPipeline = createPipeline(code, branchlessSetup.presentationFormat);
        if (newPipeline) {
          branchlessPipeline = newPipeline;
          console.log("Branchless shader recompiled successfully.");
        } else {
          alert("Failed to compile branchless shader. Check the console for errors.");
        }
      });

      // --- Handle Window Resize ---
      window.addEventListener("resize", () => {
        [branchCanvas, branchlessCanvas].forEach(canvas => {
          canvas.width = canvas.clientWidth * (window.devicePixelRatio || 1);
          canvas.height = canvas.clientHeight * (window.devicePixelRatio || 1);
        });
      });
    })();
  </script>
</body>
</html>
